# 2.4 Custom Functions, Page Objects & Actions

## 2.4.1 You've Got Me Hooked

If you recall from the previous chapter, at the beginning we had set out to write three tests. They were: 

```js
// Login Page:
// should let you log in
// should error with a missing username
// should error with a missing password
```

We completed the first, but haven't touched the other two. Let's get to that now.

Both tests are very similar. In fact, they're almost like the first test we wrote, except we will be omitting certain steps and validating the page didn't change.

Use the "test comments" practice we used in our first test, here's what our two tests will do:

```js
// - go to the login page
// - enter either a valid username or a valid password into the corresponding input
// - click the 'Sign In' button
// - assert that correct error message is shown and we aren't logged in
```

If your memory serves you well, a couple of those steps are the same as what we've already coded. And if you're lazy like me, you don't want to code anymore than you already have to.

Well, let's avoid that extra work by moving our 'go to login page' step to a common location.

MochaJS provides a feature called "hooks", that allow you to run custom test code around your tests. Each `describe` block can have any or all of the following hooks implemented:

- before
- beforeEach
- afterEach
- after

`before` and `after` are run before/after the test suite. So if you have five tests, `before` would run before the set of tests, and `after` after the tests.

`beforeEach` and `afterEach` however, execute around each test. Here's how the execution flow runs for a set of tests:

- before
- beforeEach
- test 1
- afterEach
- beforeEach
- test2
- afterEach
- after

As you can see, `beforeEach` and `afterEach` run multiple times based on the number of tests written. `before` and `after` only run at the start/end of the test suite.

Okay, enough explanation, let's see this in action. In our first test, we load the login page by running `browser.url('./login');`. This is the code we're going to want to move to our hook.

Should we use a `before` or `beforeEach` hook though? That's a good question to ask, because there are benefits/drawbacks to each. The benefit to using a `beforeEach` hook is that we can be sure our page is "fresh" for our test. Changes made in a previous test won't impact this one (mostly... sometimes this isn't true). 

On the other hand, because `beforeEach` runs for every test, every step you take in it requires one more command to be run, extending the test execution time.

For us, the decision here is pretty easy. We're going to go with a `beforeEach` hook because we definitely need a fresh page for each of our tests (we don't want an error from our `missing username` test to contaminate our `missing password` test.

With that, let's move our step over. This is what the code looks like:

{title="test/specs/login.js"}
```js
describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        $('input[type="email"]').setValue('demo@learnwebdriverio.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist({ reverse: true });

        expect($('.error-messages li')).not.toBeExisting();
    });
});
```

Not much has changed, but we've set ourselves up to do a little less work in the long run.

## 2.4.2 Getting the Error Text

As mentioned, there isn't much different between these two new tests we're writing and our previous test. That means I won't be covering what we've already talked about. So, on that note, here's what our two new tests are almost going to look like:

```js
it('should error with a missing username', function () {
    $('input[type="password"]').setValue('wdiodemo');

    $('button*=Sign in').click();

    // assert that error message is showing
});

it('should error with a missing password', function () {
    $('input[type="email"]').setValue('demo@learnwebdriverio.com');

    $('button*=Sign in').click();

    // assert that error message is showing
});
```

In our tests, we enter either the username or the password, but not both (to trigger showing an error message).

As you can see, the only work left to do is assert that the error message is showing. How do we go about this?

We have a couple of decent options:

- Re-use the error message selector we used in our first test (`$('.error-messages li')`), then validate using the `toHaveText` assertion to check our message.
- Use a 'text-based selector' to check for the specific error message (e.g. `$("li*=email can't be blank")`)

Using the second method, we'd combine our text-based selector with a `toBeExisting` assertion that runs after our test actions are executed. Here's what one test would look like:

```js
it('should error with a missing username', function () {
    $('input[type="password"]').setValue('wdiodemo');

    $('button*=Sign in').click();

    expect($("li*=email can't be blank")).toBeExisting();
});
```

Wait, shouldn't we still have the `waitForExist` command that waits for the 'Sign in' button to disappear? No, because that button stays on the page when the login fails to complete. 

One drawback to this approach is, what if the error message does show, but the error text has slightly changed? Our test will fail and we'll be left thinking the login is completely broken (when really, it still validates correctly, it's just a different message).

Alternatively, using the first approach as mentioned, we can assert the text inside of the error message. While it will still throw an error if the message changes, we'll have a much better clue as to what's going on. 

We'll do this by using `toHaveText`, which uses the `getText` command behind the scenes to check the text of the element with the expected page.

The next two snippets of code are essentially the same:

```js
expect($('.error-messages li')).toHaveText(`email can't be blank`);
```

```js
const errorText = $('.error-messages li').getText();
expect(errorText).toEqual(`email can't be blank`);
```

As you can probably guess, `getText` gets the visible text of an element. Notice that I mentioned "visible". If the element is hidden, the `getText` command will return an empty string. A great example of this is an item in a dropdown menu. Since that item isn't visible until you open up the dropdown menu, `getText` will return an empty string. If you were to open up the dropdown menu, then run `getText`, it would successfully return the text value.

There is a workaround to this issue: The `getHTML` command. Just like `getText`, `getHTML` returns the HTML value of an element, including the text inside it. Do note that as of this writing, there is no `toHaveHTML` assertion to go alongside it.

Let's look again at the HTML for our error message:

```html
<ul class="error-messages">
  <li>email can't be blank</li>
</ul>
```

Assuming that all elements are visible, here's what our `getText` and `getHTML` commands would return:

```js
$('.error-messages li').getText();
// returns "email can't be blank"

$('.error-messages li').getHTML();
// returns "<li>email can't be blank</li>"

$('.error-messages').getText();
// returns "email can't be blank"

$('.error-messages').getHTML();
// returns "<ul class="error-messages"><li>email can't be blank</li></ul>"
```

First, notice how getting the text of the parent element returned the same value as getting the text of the individual element itself. That's by design, and you can use that knowledge to your advantage, so keep it in mind.

Second, the `getHTML` included the `<li>` tags in the response. It would be a more valid test if we ignored the HTML of the page and only returned the text content. We can do that!

`getHTML` accepts a single paramenter, which is a boolean flag to include the selector element tag or not. By default it's `true`, and therefore includes that tag. If we pass in `false`, we get different results:

```js
$('.error-messages li').getHTML(false);
// returns "email can't be blank"

$('.error-messages').getHTML(false);
// returns "<li>email can't be blank</li>"
```

In the first command, now we get just the text with no HTML. However, because that boolean flag only works on the main element, any child tags will still be included in the results, regardless of what we pass in. This means that `getHTML` still has its limitations, but I still like keeping the command in my back pocket for times when I need to get the text of a hidden element. 

Since our error message shouldn't be hidden, let's stick with the `getText` route. As mentioned before, we'll use the `toHaveText` assertion to achieve this. As an added benefit, because `toHaveText` automatically retries if it fails, we don't need to add any `waitFor` commands since it's essentially built-in to it:

```js
it('should error with a missing username', function () {
    $('input[type="password"]').setValue('wdiodemo');

    $('button*=Sign in').click();

    // assert that error message is showing
    expect($('.error-messages li')).toHaveText(`email can't be blank`);
});
```

Great, we now have a fully-built test ready for running.

## 2.4.3 Only One More Thing I Don't Want to Skip

Before running our test though, I want to talk about a quick tip with Mocha. There are two special abilities to it that make it easier to work on specific tests. 

Say we're working on a test, but it's failing and we don't really have time to fix it right now. Instead of deleting or commenting out the entire test, you can add `.skip` to either the `describe` or `it` function call, and it will skip the test. Here are some examples:

```js
describe('All tests', function () {
    it('will run', function () {});

    it.skip('will be skipped', function () {});

    describe.skip('Skipped Suite', function () {
        it('will be skipped', function () {});
        it('will also be skipped', function () {});
    });
});
```

Alternatively, say you only want to run a single test (or single set of tests). You can append `.only` to the `it` or `describe` function call to have only that test (and any other tests with `only` marked) run:

```js
describe('All tests', function () {
    it('will be skipped', function () {});

    it.only('will run', function () {});

    describe.only('Only Suite', function () {
        it('will run', function () {});
        it('will also run', function () {});
    });
});
```

Notice how we can have multiple `only` tests and all of them marked as so will run? That's as intended, and you can use it to run only a few tests, instead of having to go in and run each test individually, moving the `.only` between them (or add `.skip` to all the tests you don't want running).

Okay, so we can use this new knowledge to run just the single new test that we've written. Here's what our updated file will look like:

{title="test/specs/login.js"}
```js
describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        $('input[type="email"]').setValue('demo@learnwebdriverio.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist({ reverse: true });

        expect($('.error-messages li')).not.toBeExisting();
    });

    it.only('should error with a missing username', function () {
        $('input[type="password"]').setValue('wdiodemo');

        $('button*=Sign in').click();

        // assert that error message is showing
        expect($('.error-messages li')).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        $('input[type="email"]').setValue('demo@learnwebdriverio.com');

        $('button*=Sign in').click();

        // assert that error message is showing
    });
});
```

After running our `npx wdio --spec=login.js` command from the terminal again, you should see the green checkmark next to your passing test. It's always a good idea to make sure your assertion actually works, so try changing the expected text or commenting our the `click` command to validate the test fails if that error message doesn't show. 

Since the missing password test is so similar to the missing email test, I'm going to skip over explaining it and just post the test:

```js
it('should error with a missing password', function () {
    $('input[type="email"]').setValue('demo@learnwebdriverio.com');

    $('button*=Sign in').click();

    // assert that error message is showing
    expect($('.error-messages li')).toHaveText(`password can't be blank`);
});
```

## 2.4.4 Custom Test Functions

While we did some work to reduce repetition in our code so far by using the `beforeEach` hook, there's still more we can do. If you look at the first couple steps in all three tests, we do two things:

1. Fill out the form fields
2. Click the "Sign In" button

Shouldn't we move these to the `beforeEach` function? Well no, because the specifics in each individual test vary just enough for them to not fit a common `beforeEach` function.

Rather, we're going to create a custom function that will handle the unique parts of our login steps in a common way. This function will take an email and password value, then click the 'Sign in' button. We'll call this function from inside our tests. 

Here's what the function is going to look like:

```js
function login(email, password) {
    $('input[type="email"]').setValue(email);
    $('input[type="password"]').setValue(password);

    $('button*=Sign in').click();
}
```

We're using the exact code in our first test, so let's look at how that will look replaced:

```js
it('should let you log in', function () {
    login('demo@learnwebdriverio.com', 'wdiodemo');

    $('button*=Sign in').waitForExist({ reverse: true });

    expect($('.error-messages li')).not.toBeExisting();
});
```

In place of those commands, we call the `login` function, passing in our username and password values. This simplifies our test a bit, while keeping all the same functionality (although we do now have duplicate selectors for our 'Sign in' button, but we'll fix that soon). 

So what do we do for the other tests where we don't have a value for one of our fields? Well, we just pass in an empty string:

```js
it('should error with a missing username', function () {
    login('', 'wdiodemo');
    
    // assert that error message is showing
    expect($('.error-messages li')).toHaveText(`email can't be blank`);
});
```

WebdriverIO will take that empty string and set the value of the corresponding field to it. It's technically an extra command being run, but it helps reduce repetition in our codebase so I find it worth it.

All together, here's what the updates look like:

{title="test/specs/login.js"}
```js
function login(email, password) {
    $('input[type="email"]').setValue(email);
    $('input[type="password"]').setValue(password);

    $('button*=Sign in').click();
}

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        login('demo@learnwebdriverio.com', 'wdiodemo');

        $('button*=Sign in').waitForExist({ reverse: true });

        expect($('.error-messages li')).not.toBeExisting();
    });

    it('should error with a missing username', function () {
        login('', 'wdiodemo');

        // assert that error message is showing
        expect($('.error-messages li')).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        expect($('.error-messages li')).toHaveText(`password can't be blank`);
    });
});
```

So with this custom function, we've moved browser commands into a common area, reducing the redudancy of our code, which is good. That said, it's also made the codebase more complex. Instead of being able to find everything you need for a test within it, we now have to track down this `login` function and figure out what it does. 

As with all things programming, this is a tradeoff we make. Every step to reduce the verbosity of our tests increases the complexity of it. Be mindful of this as we move into the next section... perhaps, for the sake of simplicity in a basic test suite, the following knowledge may be overdoing it in some circumstances. 

## 2.4.5 Basics of Page Objects

The function we built was pretty neat, and opens up the idea of moving implementation specifics outside of the tests and into common areas more available for re-use. Page Objects build on that idea by providing a nomenclature for defining a page and the actions you can take on it. 

We defined a "login", function, but what if we could define the "login" page itself. The specific elements on that page, and the various actions you could take upon it. That's where Page Objects slide in.

Despite the "login" function reducing some code duplication, we still had to restate the `Sign in` button selector in our first test and the 'Error Message' selector in all three. Wouldn't it be nice if we could create a common area to store all of our element selectors? 

Well, a basic system would be to define each selector as a constant, then reference that constant in our tests:

```js
const emailSelector = 'input[type="email"]';
const passwordSelector = 'input[type="password"]';
const signInSelector = 'button*=Sign in';

function login(email, password) {
    $(emailSelector).setValue(email);
    $(passwordSelector).setValue(password);

    $(signInSelector).click();
}
```

This is an improvement, but is only okay as far as code style goes. We still have to call the `$()` function a bunch, which makes the code a little bit more clunky. How about we switch those selectors to be element references?

```js
const $email = $('input[type="email"]');
const $password = $('input[type="password"]');
const $signIn = $('button*=Sign in');

function login(email, password) {
    $email.setValue(email);
    $password.setValue(password);

    $signIn.click();
}
```

Isn't that a bit better? No! It's much worse! If you tried running that code, you'd get several failures.

The reason is that we're trying to run the `$` function outside of its normal living space (this has to do with the `wdio-sync` library, but I won't go into those details). Because the constants are defined outside of the WebdriverIO context (which only exists within the specific Mocha functions), it errors out with a message of `$email.setValue is not a function`.

So what we really need is "just in time" references. We want to store the code to run to get the reference to the element, but only run that code when we're inside our tests. What if we write some cute little functions that do that?

```js
const $email = function () {
    return $('input[type="email"]');
};
const $password = function () {
    return $('input[type="password"]');
};
const $signIn = function () {
    return $('button*=Sign in');
};

function login(email, password) {
    $email().setValue(email);
    $password().setValue(password);

    $signIn().click();
}
```

Okay, so that code works, but geez is it ugly. Having to call our element references as a function every time we want to access them? Certainly there's a cleaner way of achieving the same effect...

Surprise, there is! Okay... maybe not surprise. I kind of worked too hard to set myself up for all of this.

Regardless, newer versions of JavaScript let us achieve this with a much cleaner syntax. Using the `class` syntax (introduced in ECMAScript 2015 for those keeping track), we can define `get` functions that look like standard variables, but act like functions. 

First, we need to define a new `class` to hold all of our authentication related information:

```js
class Auth {
}
```

Then, we define our `get` functions inside of it:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}
```

The `get` functions mirror our earlier element reference functions, so it should look familiar. But we don't access them by calling `Auth.$email()`. There is an extra step we need to take to make it all work.

When you define a `class`, you're stating how something "should" work. It's not the same as defining a variable or constant, which are able to be referenced right away. No, with a class, you first have to "instantiate" it. Instantiate is a big fancy term meaning "the creation of a real instance or particular realization of an abstraction or template such as a class." Did that not help? Well, it basically means we're creating a new instance of something, in this case, the class we've just defined.

So we need to "instantiate" our class before we can use it. That's pretty easy:

```js
const auth = new Auth();
```

We call `new` on our Auth class like it's a function, and store it as an `auth` constant. Now we have a real reference that we can use in our test. 

Collectively, this is how our code now looks using classes:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

function login(email, password) {
    auth.$email.setValue(email);
    auth.$password.setValue(password);

    auth.$signIn.click();
}
```

We got rid of the function call for each of our element references, and prepended everything with our `auth` instantiated class. If you're counting text characters, we've actually gone up, but to me it feels a lot cleaner and more self-documenting. All the elements related to authentication are stored inside of the Auth instance. 

One added benefit of this approach is that we can use this `auth` instance throughout our tests. Here's what the fully updated test suite looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

function login(email, password) {
    auth.$email.setValue(email);
    auth.$password.setValue(password);

    auth.$signIn.click();
}

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        login('demo@learnwebdriverio.com', 'wdiodemo');

        auth.$signIn.waitForExist({ reverse: true });

        expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', function () {
        login('', 'wdiodemo');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

Notice how the tests themselves no longer store the selector information. All of those details are inside of our page object. This [seperation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) helps reduce maintanence efforts (less places to change things) and improves readability. Instead of our test code being cluttered with selectors, they have more understandable references.

## 2.4.6 Naming Patterns

Speaking of, how should you name your variables? Overall, that's a individual/team choice, but there are a few things you'll want to consider.

One option is to include the element type in the variable name (e.g. `$emailInput`, `$passwordInput`). While it's nice to know we're working with an input element, there are couple drawbacks of this approach:

1. It's more verbose. You can remidiate this by using shorter names: `inp` vs `input` or `lbl` instead of `label`. But then that can be confusing to folks unfamiliar with the nomenclature. 
2. Not all elements line up nicely with an element name. For example, container elements. Are you going to name it `accordionContainer` or `accordionDiv`? Are you going to name a list as `todoList` or `todoUl`?

I'm not saying including element information is a bad idea, only that you need to map out how you plan on being consistent with your naming pattern.

Another consideration is how you'll name types of components. For example, if you're testing a to-do list, you might have the following HTML:

```html
<ul>
    <li>Item 1</li>
    <li>Item 2</li>
</ul>
```

Here's what the page object may look like:

```js
class TodoList {
    get $container () { return $('ul'); }
    get $$items () { return $$('li'); }
}
```

But it could also be:

```js
class TodoGroup {
    get $parent () { return $('ul'); }
    get $$tasks () { return $$('li'); }
}
```

Either are valid and work well, but the naming scheme is definitely different between the two. Inconsisten naming patterns can cause confusion for newcomers to the codebase, so work on being clear with the pattern you want to define from the start.

## 2.4.7 Page Actions

We were able to move our selectors out of our tests and into our page object; can we do they same with the login function? It's technically part of our "Auth" flow, and it would be great to group it inside of our Auth page object for reuse across our tests.

Yes, we certainly can move it, and that's just what we're going to do next. 

JavaScript classes, which is what we've been using so far to define our page object, allow you to define functions on them (as well as the 'getters' we've already used for our element references). You add these functions in a pretty similar format as normal functions live in the wild.

Instead of declaring your function on its own, you include inside the curly braces that define our class. Let's update our class to declare a "login" function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
    
    login (email, password) {
        // login actions go here
    }
}

const auth = new Auth();
```

I didn't include the steps in the function yet, as there's a slight tweak we need to make to the login code. Recall how the login function referenced the `auth` instance we created (e.g., `auth.$signIn.click()`)? If we try a straight copy/paste of that, the code will run successfully, but a bug will be lurking beneath the surface. 

When our function commands reference `auth`, they're talking about the specific `auth` instance that's later created in our code. Our page object has no real control over what this instance is named, so any changes to that name will break the code.

For instance, if the instantiation is changed to `const authentication = new Auth();`, our login function will error out with `auth is not defined`, as `auth` no longer exists. This means our function is brittle and liable to break with outside code changes. It's a bad situation to put yourself in.

How do we work around this issue? Well, conveniently, JavaScript classes give us a pre-defined `this` keyword that we can use to reference whatever instance of our class is. We don't need to declare it anywhere, it exists as part of the normal runtime (similar to how we don't define `browser`, it already exists when we run our code).

JavaScript `this` can be a bit confusing, and we'll get in to scenarios in the future where that's true. In our code right now though, just imagine that `this` is a reference to the overall class. Let's add the commands into our function, replacing `auth` with `this` as necessary:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();
    }
}
```

Now the `const auth = new Auth();` instantiation can be named anything and our code will still work. By using the magic of `this`, we alleviate the need to know what our instance will be named.

There's one last item to complete in our transition to page actions: we need to update our `login` reference in our test code. Since we want to call the `login` function that belongs to our `auth` instance, we can refer to it in the same way we've accessed our element reference: by prepending the instance name (i.e., `auth`) to our function name. 

So `login('demowdio@example.com', 'wdiodemo');` becomes `auth.login('demowdio@example.com', 'wdiodemo');`. Now when we run the code, it will look for the `login` function on the `auth` page object instance. Here's what the entire file now looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();
    }
}

const auth = new Auth();

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        auth.login('demo@learnwebdriverio.com', 'wdiodemo');

        auth.$signIn.waitForExist({ reverse: true });

        expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', function () {
        auth.login('', 'wdiodemo');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        auth.login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

We've now fully built-out our page object with element references and custom functions. This framework will be used throughout our tests moving forward, so be prepared to see a lot of this. It might feel a bit over-complicated right now, but it opens up opportunities for extension in the future that we'll be covering in the next chapter. 

## 2.4.8 Improving Our Login Detection

We've gotten rid of the code duplication between our tests, but there's one final step we can take to reduce future duplication. When we login, we have a `waitForExist` command that pauses execution until the page has updated (i.e., `auth.$signIn.waitForExist({ reverse: true });`). Right now we're only using it once, but we'll be using this login function a lot in the future when we tests pages that require user login. 

But we can't just move that `waitForExist` command into our login function, because then our other two tests will fail as the `Sign in` button never disappears in those flows. How do we get around this?

I mentioned the `waitUntil` function a while back; now it's time to take advantage of it. 

As I mentioned, in our three tests, there are two different conditions we wait for:

Either:
1. For the login button to stop existing: `auth.$signIn.waitForExist({ reverse: true });`
2. For an error message to exist: `auth.$errorMessages.waitForExist();`

On the outside, it doesn't make sense to try and combine these, as one is for a successful login and the other is for a failed login. But what if we could say "Wait for either this *or* that"?

This is where a custom `waitUntil` command comes in. It's your universal weapon if you want to wait on some specific scenario. It expects a condition and waits until that condition is fulfilled with a truthy value. 

With it, we can say "Wait for the login button to disappear or for an error message to exist". To use the `waitUntil` method, call it and pass in a function that returns a true or false value, depending on if the condition is met. WebdriverIO will keep waiting/calling that function until it either returns true, or reaches the timeout limit. 

For our login method, we can write our function as follows:

```js
browser.waitUntil(function () {
    const signInExists = auth.$signIn.isExisting();
    const errorExists = auth.$errorMessages.isExisting();

    return !signInExists || errorExists;
});
```

Our return statement will return true on any of the following conditions (`||` means 'or', if you're not familiar with it):

- The 'Sign in' button no longer exists (`!` reverses the value of `signInExists`)
- An error exists

Because `waitUntil` automatically retries, our function will continue to return false until either of those conditions is met (checking every half a second by default). If that condition isn't met by our `waitForTimeout` amount, it will fail saying `waitUntil condition timed out after 10000ms`.

Well, that message isn't very helpful. We know `waitUntil` failed, but unless you were expecting the failure (which you likely weren't), you're going to have to dig in the code to figure out what condition it was. 

We can help that by passing in a custom error message. The `waitUntil` function signature looks like: 

```js
browser.waitUntil(condition, { timeout, timeoutMsg, interval });
```

The `condition` is our function, which is required. After that is an options object. This object is almost the same as what we have for `waitForExist` (`reverse` isn't included, as it's not needed).

The `timeoutMsg` option is the custom error message we want to show in case of failure. We can leave out the rest so they'll go with the defaults.

Here's what this looks like:

```js
browser.waitUntil(
    function () {
        const signInExists = auth.$signIn.isExisting();
        const errorExists = auth.$errorMessages.isExisting();

        return !signInExists || errorExists;
    },
    { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
);
```

Perfect! Now we can remove that `waitForExist` statement in our test code and add our new `waitUntil` function to our `login` function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error appears
        browser.waitUntil(
            () => {
                const signInExists = this.$signIn.isExisting();
                const errorExists = this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            {
                timoutMsg:
                    'The "Sign in" button still exists and an error never appeared'
            }
        );
    }
}
```

Two important things to point out that I changed here.

1. I updated `auth.` to `this.` (e.g. `auth.$signIn.isExisting()` -> `this.$signIn.isExisting()`). That's inline with the changes we made earlier.
2. I used a `fat arrow` function definition, instead of the previous `function () {}`. That's because our `waitUntil` function will be called with a different `this` value if we don't use it.

Remember how I said `this` can be tricky? Well, here's your example. If we used the following code:

```js
browser.waitUntil(
    function () {
        const signInExists = this.$signIn.isExisting();
        const errorExists = this.$errorMessages.isExisting();

        return !signInExists || errorExists;
    },
    { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
);
```

The `this` in our code wouldn't refer to our page object, but rather the WebdriverIO `browser` instance (so it would be the same as calling `browser.$signIn.isExisting()`, which doesn't work). By using a fat arrow function, we bind `this` to the page object, allowing us to say `this.$signIn.isExisting();`. 

For more details on fat arrow functions, have a read through this in-depth article: https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/

Here's what our fully updated `login.js` file looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login(email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error appears
        browser.waitUntil(
            () => {
                const signInExists = this.$signIn.isExisting();
                const errorExists = this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            {
                timoutMsg:
                    'The "Sign in" button still exists and an error never appeared'
            }
        );
    }
}

const auth = new Auth();

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        auth.login('demo@learnwebdriverio.com', 'wdiodemo');

        expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', function () {
        auth.login('', 'wdiodemo');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        auth.login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

## 2.4.9: Separating Files

We've finished with our Page Object/Actions, but there's still one last thing to do. As we move forward with new tests, it will be really helpful to have this Auth page object available elsewhere. It's a very good idea to separate out your page objects from your test files, so let's do that. 

Grab all of your `class` code and move it to a new file that looks like:

{title="test/pageObjects/Auth.page.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login(email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error appears
        browser.waitUntil(
            () => {
                const signInExists = this.$signIn.isExisting();
                const errorExists = this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            {
                timoutMsg:
                    'The "Sign in" button still exists and an error never appeared'
            }
        );
    }
}

module.exports = Auth;
```

In addition to the moved code, at the very bottom, we added an 'export' for our class via Node's export system. We did this by attaching our class to the `module.export` value ([Node.js technical docs on `module.export`](https://nodejs.org/api/modules.html#modules_exports_shortcut)). Without this, our class wouldn't get exported from the file, which would be bad.

Now we need to save our file. First, we need a new folder to save our page object in. If we save it to our specs folder, WebdriverIO will think it's a test spec file and try running it at so. Instead, let's save it outside of the `test/specs` folder, to a specific page objects folder at `test/pageObjects`.

For the filename, I like to use a leading capital letter, signifying that we've exported a single class. I also like to append `.page` in my filename, to let others know that this is a page object definition. So my filename will be saved to `test/pageObjects/Auth.page.js`.

Finally, back in our test file, we need to import our page object for usage. This is what the top of the file will now look like:

```js
const Auth = require('../pageObjects/Auth.page');

const auth = new Auth();
```

With everything moved around and hooked up, you can run your tests one more time to ensure it's all plugged in correctly.

In the next chapter, we're going to to use our new Auth page object to help ourselves get logged in, so we can test all sorts of authenticated functionality.

## 2.4.10 Chapter Challenge

- Write a set of tests for the register account page that checks the following requirements
  - Requires username, email, password
  - errors if username is already taken
  - errors if email is not a valid format (e.g. missing `@`)
  - errors if email has already been taken
  - Takes you to home page once you register
